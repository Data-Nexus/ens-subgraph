enum OwnershipLevel {
  REGISTRY
  REGISTRAR
  NAMEWRAPPER
}

type Name @entity {
  id: ID!                                               # The namehash of the name
  labelhash: Bytes                                      # keccak256(labelName)

  name: String                                          # The human readable name, if known. Unknown portions replaced with hash in square brackets (eg, foo.[1234].eth)
  labelName: String                                     # The human readable label name (imported from CSV), if known

  parent: Name                                          # The namehash (id) of the parent name

  subnames: [Name!]! @derivedFrom(field: "parent")      # Can count domains from length of array
  subnameCount: Int!                                    # The number of subdomains
  
  owner: Account!
  ownershipLevel: OwnershipLevel!
  ttl: BigInt
  isMigrated: Boolean!
  createdAt: BigInt!

  resolver: Resolver
  resolvedAddress: Account                              # Address logged from current resolver, if any

  events: [NameEvent!]! @derivedFrom(field: "name")

  # Registrations
  registrationDate: BigInt
  expiryDate: BigInt
  cost: BigInt

  # Unwrapped Names
  registrant: Account

  # Wrapped Names
  fuses: BigInt
}

type Account @entity {
  id: ID!
  names: [Name!]! @derivedFrom(field: "owner")
  registrations: [Name!] @derivedFrom(field: "registrant")
}

type Resolver @entity {
  id: ID!                   # Concatenation of resolver address and namehash
  name: Name
  address: Bytes!           # Address of resolver contract

  addr: Account             # Current value of addr record (per events)
  contentHash: Bytes        # Content hash, in binary format.
  texts: [String!]          # Set of observed text record keys
  coinTypes: [BigInt!]      # Set of observed SLIP-44 coin types
  events: [ResolverEvent!]! @derivedFrom(field: "resolver")
}

interface NameEvent {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
}

interface RegistryEvent implements NameEvent {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
}

interface RegistrarEvent implements NameEvent {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
}

interface WrapperEvent implements NameEvent {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
}

interface ResolverEvent {
  id: ID!                   # Concatenation of block number and log ID
  resolver: Resolver!       # Used to derive relationships to Resolvers
  blockNumber: Int!
  transactionID: Bytes!
}

type Transfer implements RegistryEvent @entity {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
  owner: Account!
}

type NewOwner implements RegistryEvent @entity {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
  parentName: Name!
  owner: Account!
}

type NewResolver implements RegistryEvent @entity {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
  resolver: Resolver!
}

type NewTTL implements RegistryEvent @entity {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
  ttl: BigInt!
}

type NameRegistered implements RegistrarEvent @entity {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
  owner: Account
  registrant: Account
  expiryDate: BigInt!
  baseCost: BigInt!
  premium: BigInt
}

type NameRenewed implements RegistrarEvent @entity {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
  expiryDate: BigInt!
  baseCost: BigInt!
}

type NameTransferred implements RegistrarEvent @entity {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
  newOwner: Account!
}

type NameWrapped implements WrapperEvent @entity  {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
  fuses: BigInt!
  owner: Account!
}

type NameUnwrapped implements WrapperEvent @entity  {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
  owner: Account!
}

type FusesSet implements WrapperEvent @entity  {
  id: ID!
  name: Name!
  blockNumber: Int!
  transactionID: Bytes!
  fuses: BigInt! 
}

type AddrChanged implements ResolverEvent @entity {
  id: ID!                   
  resolver: Resolver!       
  blockNumber: Int!
  transactionID: Bytes!
  addr: Account!
}

type MulticoinAddrChanged implements ResolverEvent @entity {
  id: ID!                   
  resolver: Resolver!       
  blockNumber: Int!
  transactionID: Bytes!
  coinType: BigInt!
  addr: Bytes!
}

type NameChanged implements ResolverEvent @entity {
  id: ID!                   
  resolver: Resolver!       
  blockNumber: Int!
  transactionID: Bytes!
  name: String!
}

type AbiChanged implements ResolverEvent @entity {
  id: ID!                   
  resolver: Resolver!       
  blockNumber: Int!
  transactionID: Bytes!
  contentType: BigInt!
}

type PubkeyChanged implements ResolverEvent @entity {
  id: ID!                   
  resolver: Resolver!       
  blockNumber: Int!
  transactionID: Bytes!
  x: Bytes!
  y: Bytes!
}

type TextChanged implements ResolverEvent @entity {
  id: ID!                   
  resolver: Resolver!       
  blockNumber: Int!
  transactionID: Bytes!
  key: String!
  value: String
}

type ContenthashChanged implements ResolverEvent @entity {
  id: ID!                   
  resolver: Resolver!       
  blockNumber: Int!
  transactionID: Bytes!
  hash: Bytes!
}

type InterfaceChanged implements ResolverEvent @entity {
  id: ID!                   
  resolver: Resolver!       
  blockNumber: Int!
  transactionID: Bytes!
  interfaceID: Bytes!
  implementer: Bytes!
}

type AuthorisationChanged implements ResolverEvent @entity {
  id: ID!                   
  resolver: Resolver!       
  blockNumber: Int!
  transactionID: Bytes!
  owner: Bytes!
  target: Bytes!
  isAuthorized: Boolean!
}
